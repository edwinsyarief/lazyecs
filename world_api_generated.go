// Code generated by go generate; DO NOT EDIT.
package lazyecs

import (
	"reflect"
	"unsafe"
)

// GetComponents2 returns pointers to the components of type T1, T2 for the entity, or nil if not present or invalid.
func GetComponents2[T1 any, T2 any](w *World, e Entity) (*T1, *T2, bool) {
	if !w.IsValid(e) {
		return nil, nil, false
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	
	if id2 == id1 {
		panic("ecs: duplicate component types in GetComponents2")
	}
	meta := w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]
	var m bitmask256
	m.set(id1)
	m.set(id2)
	
	if !a.mask.contains(m) {
		return nil, nil, false
	}
	p1 := unsafe.Pointer(uintptr(a.compPointers[id1]) + uintptr(meta.index)*a.compSizes[id1])
	p2 := unsafe.Pointer(uintptr(a.compPointers[id2]) + uintptr(meta.index)*a.compSizes[id2])
	
	return (*T1)(p1), (*T2)(p2), true
}

// SetComponents2 sets the components of type T1, T2 on the entity, adding them if not present.
func SetComponents2[T1 any, T2 any](w *World, e Entity, c1 T1, c2 T2) {
	if !w.IsValid(e) {
		return
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	
	if id2 == id1 {
		panic("ecs: duplicate component types in SetComponents2")
	}
	meta := &w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]

	var setMask bitmask256
	setMask.set(id1)
	setMask.set(id2)
	

	if a.mask.contains(setMask) {
		// already has all, just set
		p1 := unsafe.Pointer(uintptr(a.compPointers[id1]) + uintptr(meta.index)*a.compSizes[id1])
		*(*T1)(p1) = c1
		p2 := unsafe.Pointer(uintptr(a.compPointers[id2]) + uintptr(meta.index)*a.compSizes[id2])
		*(*T2)(p2) = c2
		
		return
	}

	newMask := a.mask
	newMask.set(id1)
	newMask.set(id2)
	

	var tempSpecs [MaxComponentTypes]compSpec
	count := 0
	for i := uint8(0); i < uint8(w.nextCompTypeID); i++ {
		var bm bitmask256
		bm.set(i)
		if newMask.contains(bm) {
			typ := w.compIDToType[i]
			tempSpecs[count] = compSpec{i, typ, typ.Size()}
			count++
		}
	}
	specs := tempSpecs[:count]
	targetA := w.getOrCreateArchetype(newMask, specs)

	newIdx := targetA.size
	targetA.entityIDs[newIdx] = e
	targetA.size++

	for _, cid := range a.compOrder {
		src := unsafe.Pointer(uintptr(a.compPointers[cid]) + uintptr(meta.index)*a.compSizes[cid])
		dst := unsafe.Pointer(uintptr(targetA.compPointers[cid]) + uintptr(newIdx)*targetA.compSizes[cid])
		memCopy(dst, src, a.compSizes[cid])
	}

	
	{
		var singleMask bitmask256
		singleMask.set(id1)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id1]) + uintptr(newIdx)*targetA.compSizes[id1])
			*(*T1)(dst) = c1
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id2)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id2]) + uintptr(newIdx)*targetA.compSizes[id2])
			*(*T2)(dst) = c2
		}
	}
	

	w.removeFromArchetype(a, meta)

	meta.archetypeIndex = targetA.index
	meta.index = newIdx
}

// RemoveComponents2 removes the components of type T1, T2 from the entity if present.
func RemoveComponents2[T1 any, T2 any](w *World, e Entity) {
	if !w.IsValid(e) {
		return
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	
	if id2 == id1 {
		panic("ecs: duplicate component types in RemoveComponents2")
	}
	meta := &w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]

	var removeMask bitmask256
	removeMask.set(id1)
	removeMask.set(id2)
	

	if !a.mask.intersects(removeMask) {
		return
	}

	newMask := a.mask
	newMask.unset(id1)
	newMask.unset(id2)
	

	var tempSpecs [MaxComponentTypes]compSpec
	count := 0
	for i := uint8(0); i < uint8(w.nextCompTypeID); i++ {
		var bm bitmask256
		bm.set(i)
		if newMask.contains(bm) {
			typ := w.compIDToType[i]
			tempSpecs[count] = compSpec{i, typ, typ.Size()}
			count++
		}
	}
	specs := tempSpecs[:count]
	targetA := w.getOrCreateArchetype(newMask, specs)

	newIdx := targetA.size
	targetA.entityIDs[newIdx] = e
	targetA.size++

	for _, cid := range a.compOrder {
		var bm bitmask256
		bm.set(cid)
		if removeMask.contains(bm) {
			continue
		}
		src := unsafe.Pointer(uintptr(a.compPointers[cid]) + uintptr(meta.index)*a.compSizes[cid])
		dst := unsafe.Pointer(uintptr(targetA.compPointers[cid]) + uintptr(newIdx)*targetA.compSizes[cid])
		memCopy(dst, src, a.compSizes[cid])
	}

	w.removeFromArchetype(a, meta)

	meta.archetypeIndex = targetA.index
	meta.index = newIdx
}// GetComponents3 returns pointers to the components of type T1, T2, T3 for the entity, or nil if not present or invalid.
func GetComponents3[T1 any, T2 any, T3 any](w *World, e Entity) (*T1, *T2, *T3, bool) {
	if !w.IsValid(e) {
		return nil, nil, nil, false
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	
	if id2 == id1 || id3 == id1 || id3 == id2 {
		panic("ecs: duplicate component types in GetComponents3")
	}
	meta := w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]
	var m bitmask256
	m.set(id1)
	m.set(id2)
	m.set(id3)
	
	if !a.mask.contains(m) {
		return nil, nil, nil, false
	}
	p1 := unsafe.Pointer(uintptr(a.compPointers[id1]) + uintptr(meta.index)*a.compSizes[id1])
	p2 := unsafe.Pointer(uintptr(a.compPointers[id2]) + uintptr(meta.index)*a.compSizes[id2])
	p3 := unsafe.Pointer(uintptr(a.compPointers[id3]) + uintptr(meta.index)*a.compSizes[id3])
	
	return (*T1)(p1), (*T2)(p2), (*T3)(p3), true
}

// SetComponents3 sets the components of type T1, T2, T3 on the entity, adding them if not present.
func SetComponents3[T1 any, T2 any, T3 any](w *World, e Entity, c1 T1, c2 T2, c3 T3) {
	if !w.IsValid(e) {
		return
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	
	if id2 == id1 || id3 == id1 || id3 == id2 {
		panic("ecs: duplicate component types in SetComponents3")
	}
	meta := &w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]

	var setMask bitmask256
	setMask.set(id1)
	setMask.set(id2)
	setMask.set(id3)
	

	if a.mask.contains(setMask) {
		// already has all, just set
		p1 := unsafe.Pointer(uintptr(a.compPointers[id1]) + uintptr(meta.index)*a.compSizes[id1])
		*(*T1)(p1) = c1
		p2 := unsafe.Pointer(uintptr(a.compPointers[id2]) + uintptr(meta.index)*a.compSizes[id2])
		*(*T2)(p2) = c2
		p3 := unsafe.Pointer(uintptr(a.compPointers[id3]) + uintptr(meta.index)*a.compSizes[id3])
		*(*T3)(p3) = c3
		
		return
	}

	newMask := a.mask
	newMask.set(id1)
	newMask.set(id2)
	newMask.set(id3)
	

	var tempSpecs [MaxComponentTypes]compSpec
	count := 0
	for i := uint8(0); i < uint8(w.nextCompTypeID); i++ {
		var bm bitmask256
		bm.set(i)
		if newMask.contains(bm) {
			typ := w.compIDToType[i]
			tempSpecs[count] = compSpec{i, typ, typ.Size()}
			count++
		}
	}
	specs := tempSpecs[:count]
	targetA := w.getOrCreateArchetype(newMask, specs)

	newIdx := targetA.size
	targetA.entityIDs[newIdx] = e
	targetA.size++

	for _, cid := range a.compOrder {
		src := unsafe.Pointer(uintptr(a.compPointers[cid]) + uintptr(meta.index)*a.compSizes[cid])
		dst := unsafe.Pointer(uintptr(targetA.compPointers[cid]) + uintptr(newIdx)*targetA.compSizes[cid])
		memCopy(dst, src, a.compSizes[cid])
	}

	
	{
		var singleMask bitmask256
		singleMask.set(id1)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id1]) + uintptr(newIdx)*targetA.compSizes[id1])
			*(*T1)(dst) = c1
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id2)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id2]) + uintptr(newIdx)*targetA.compSizes[id2])
			*(*T2)(dst) = c2
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id3)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id3]) + uintptr(newIdx)*targetA.compSizes[id3])
			*(*T3)(dst) = c3
		}
	}
	

	w.removeFromArchetype(a, meta)

	meta.archetypeIndex = targetA.index
	meta.index = newIdx
}

// RemoveComponents3 removes the components of type T1, T2, T3 from the entity if present.
func RemoveComponents3[T1 any, T2 any, T3 any](w *World, e Entity) {
	if !w.IsValid(e) {
		return
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	
	if id2 == id1 || id3 == id1 || id3 == id2 {
		panic("ecs: duplicate component types in RemoveComponents3")
	}
	meta := &w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]

	var removeMask bitmask256
	removeMask.set(id1)
	removeMask.set(id2)
	removeMask.set(id3)
	

	if !a.mask.intersects(removeMask) {
		return
	}

	newMask := a.mask
	newMask.unset(id1)
	newMask.unset(id2)
	newMask.unset(id3)
	

	var tempSpecs [MaxComponentTypes]compSpec
	count := 0
	for i := uint8(0); i < uint8(w.nextCompTypeID); i++ {
		var bm bitmask256
		bm.set(i)
		if newMask.contains(bm) {
			typ := w.compIDToType[i]
			tempSpecs[count] = compSpec{i, typ, typ.Size()}
			count++
		}
	}
	specs := tempSpecs[:count]
	targetA := w.getOrCreateArchetype(newMask, specs)

	newIdx := targetA.size
	targetA.entityIDs[newIdx] = e
	targetA.size++

	for _, cid := range a.compOrder {
		var bm bitmask256
		bm.set(cid)
		if removeMask.contains(bm) {
			continue
		}
		src := unsafe.Pointer(uintptr(a.compPointers[cid]) + uintptr(meta.index)*a.compSizes[cid])
		dst := unsafe.Pointer(uintptr(targetA.compPointers[cid]) + uintptr(newIdx)*targetA.compSizes[cid])
		memCopy(dst, src, a.compSizes[cid])
	}

	w.removeFromArchetype(a, meta)

	meta.archetypeIndex = targetA.index
	meta.index = newIdx
}// GetComponents4 returns pointers to the components of type T1, T2, T3, T4 for the entity, or nil if not present or invalid.
func GetComponents4[T1 any, T2 any, T3 any, T4 any](w *World, e Entity) (*T1, *T2, *T3, *T4, bool) {
	if !w.IsValid(e) {
		return nil, nil, nil, nil, false
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	t4 := reflect.TypeFor[T4]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	id4 := w.getCompTypeID(t4)
	
	if id2 == id1 || id3 == id1 || id3 == id2 || id4 == id1 || id4 == id2 || id4 == id3 {
		panic("ecs: duplicate component types in GetComponents4")
	}
	meta := w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]
	var m bitmask256
	m.set(id1)
	m.set(id2)
	m.set(id3)
	m.set(id4)
	
	if !a.mask.contains(m) {
		return nil, nil, nil, nil, false
	}
	p1 := unsafe.Pointer(uintptr(a.compPointers[id1]) + uintptr(meta.index)*a.compSizes[id1])
	p2 := unsafe.Pointer(uintptr(a.compPointers[id2]) + uintptr(meta.index)*a.compSizes[id2])
	p3 := unsafe.Pointer(uintptr(a.compPointers[id3]) + uintptr(meta.index)*a.compSizes[id3])
	p4 := unsafe.Pointer(uintptr(a.compPointers[id4]) + uintptr(meta.index)*a.compSizes[id4])
	
	return (*T1)(p1), (*T2)(p2), (*T3)(p3), (*T4)(p4), true
}

// SetComponents4 sets the components of type T1, T2, T3, T4 on the entity, adding them if not present.
func SetComponents4[T1 any, T2 any, T3 any, T4 any](w *World, e Entity, c1 T1, c2 T2, c3 T3, c4 T4) {
	if !w.IsValid(e) {
		return
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	t4 := reflect.TypeFor[T4]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	id4 := w.getCompTypeID(t4)
	
	if id2 == id1 || id3 == id1 || id3 == id2 || id4 == id1 || id4 == id2 || id4 == id3 {
		panic("ecs: duplicate component types in SetComponents4")
	}
	meta := &w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]

	var setMask bitmask256
	setMask.set(id1)
	setMask.set(id2)
	setMask.set(id3)
	setMask.set(id4)
	

	if a.mask.contains(setMask) {
		// already has all, just set
		p1 := unsafe.Pointer(uintptr(a.compPointers[id1]) + uintptr(meta.index)*a.compSizes[id1])
		*(*T1)(p1) = c1
		p2 := unsafe.Pointer(uintptr(a.compPointers[id2]) + uintptr(meta.index)*a.compSizes[id2])
		*(*T2)(p2) = c2
		p3 := unsafe.Pointer(uintptr(a.compPointers[id3]) + uintptr(meta.index)*a.compSizes[id3])
		*(*T3)(p3) = c3
		p4 := unsafe.Pointer(uintptr(a.compPointers[id4]) + uintptr(meta.index)*a.compSizes[id4])
		*(*T4)(p4) = c4
		
		return
	}

	newMask := a.mask
	newMask.set(id1)
	newMask.set(id2)
	newMask.set(id3)
	newMask.set(id4)
	

	var tempSpecs [MaxComponentTypes]compSpec
	count := 0
	for i := uint8(0); i < uint8(w.nextCompTypeID); i++ {
		var bm bitmask256
		bm.set(i)
		if newMask.contains(bm) {
			typ := w.compIDToType[i]
			tempSpecs[count] = compSpec{i, typ, typ.Size()}
			count++
		}
	}
	specs := tempSpecs[:count]
	targetA := w.getOrCreateArchetype(newMask, specs)

	newIdx := targetA.size
	targetA.entityIDs[newIdx] = e
	targetA.size++

	for _, cid := range a.compOrder {
		src := unsafe.Pointer(uintptr(a.compPointers[cid]) + uintptr(meta.index)*a.compSizes[cid])
		dst := unsafe.Pointer(uintptr(targetA.compPointers[cid]) + uintptr(newIdx)*targetA.compSizes[cid])
		memCopy(dst, src, a.compSizes[cid])
	}

	
	{
		var singleMask bitmask256
		singleMask.set(id1)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id1]) + uintptr(newIdx)*targetA.compSizes[id1])
			*(*T1)(dst) = c1
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id2)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id2]) + uintptr(newIdx)*targetA.compSizes[id2])
			*(*T2)(dst) = c2
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id3)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id3]) + uintptr(newIdx)*targetA.compSizes[id3])
			*(*T3)(dst) = c3
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id4)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id4]) + uintptr(newIdx)*targetA.compSizes[id4])
			*(*T4)(dst) = c4
		}
	}
	

	w.removeFromArchetype(a, meta)

	meta.archetypeIndex = targetA.index
	meta.index = newIdx
}

// RemoveComponents4 removes the components of type T1, T2, T3, T4 from the entity if present.
func RemoveComponents4[T1 any, T2 any, T3 any, T4 any](w *World, e Entity) {
	if !w.IsValid(e) {
		return
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	t4 := reflect.TypeFor[T4]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	id4 := w.getCompTypeID(t4)
	
	if id2 == id1 || id3 == id1 || id3 == id2 || id4 == id1 || id4 == id2 || id4 == id3 {
		panic("ecs: duplicate component types in RemoveComponents4")
	}
	meta := &w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]

	var removeMask bitmask256
	removeMask.set(id1)
	removeMask.set(id2)
	removeMask.set(id3)
	removeMask.set(id4)
	

	if !a.mask.intersects(removeMask) {
		return
	}

	newMask := a.mask
	newMask.unset(id1)
	newMask.unset(id2)
	newMask.unset(id3)
	newMask.unset(id4)
	

	var tempSpecs [MaxComponentTypes]compSpec
	count := 0
	for i := uint8(0); i < uint8(w.nextCompTypeID); i++ {
		var bm bitmask256
		bm.set(i)
		if newMask.contains(bm) {
			typ := w.compIDToType[i]
			tempSpecs[count] = compSpec{i, typ, typ.Size()}
			count++
		}
	}
	specs := tempSpecs[:count]
	targetA := w.getOrCreateArchetype(newMask, specs)

	newIdx := targetA.size
	targetA.entityIDs[newIdx] = e
	targetA.size++

	for _, cid := range a.compOrder {
		var bm bitmask256
		bm.set(cid)
		if removeMask.contains(bm) {
			continue
		}
		src := unsafe.Pointer(uintptr(a.compPointers[cid]) + uintptr(meta.index)*a.compSizes[cid])
		dst := unsafe.Pointer(uintptr(targetA.compPointers[cid]) + uintptr(newIdx)*targetA.compSizes[cid])
		memCopy(dst, src, a.compSizes[cid])
	}

	w.removeFromArchetype(a, meta)

	meta.archetypeIndex = targetA.index
	meta.index = newIdx
}// GetComponents5 returns pointers to the components of type T1, T2, T3, T4, T5 for the entity, or nil if not present or invalid.
func GetComponents5[T1 any, T2 any, T3 any, T4 any, T5 any](w *World, e Entity) (*T1, *T2, *T3, *T4, *T5, bool) {
	if !w.IsValid(e) {
		return nil, nil, nil, nil, nil, false
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	t4 := reflect.TypeFor[T4]()
	t5 := reflect.TypeFor[T5]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	id4 := w.getCompTypeID(t4)
	id5 := w.getCompTypeID(t5)
	
	if id2 == id1 || id3 == id1 || id3 == id2 || id4 == id1 || id4 == id2 || id4 == id3 || id5 == id1 || id5 == id2 || id5 == id3 || id5 == id4 {
		panic("ecs: duplicate component types in GetComponents5")
	}
	meta := w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]
	var m bitmask256
	m.set(id1)
	m.set(id2)
	m.set(id3)
	m.set(id4)
	m.set(id5)
	
	if !a.mask.contains(m) {
		return nil, nil, nil, nil, nil, false
	}
	p1 := unsafe.Pointer(uintptr(a.compPointers[id1]) + uintptr(meta.index)*a.compSizes[id1])
	p2 := unsafe.Pointer(uintptr(a.compPointers[id2]) + uintptr(meta.index)*a.compSizes[id2])
	p3 := unsafe.Pointer(uintptr(a.compPointers[id3]) + uintptr(meta.index)*a.compSizes[id3])
	p4 := unsafe.Pointer(uintptr(a.compPointers[id4]) + uintptr(meta.index)*a.compSizes[id4])
	p5 := unsafe.Pointer(uintptr(a.compPointers[id5]) + uintptr(meta.index)*a.compSizes[id5])
	
	return (*T1)(p1), (*T2)(p2), (*T3)(p3), (*T4)(p4), (*T5)(p5), true
}

// SetComponents5 sets the components of type T1, T2, T3, T4, T5 on the entity, adding them if not present.
func SetComponents5[T1 any, T2 any, T3 any, T4 any, T5 any](w *World, e Entity, c1 T1, c2 T2, c3 T3, c4 T4, c5 T5) {
	if !w.IsValid(e) {
		return
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	t4 := reflect.TypeFor[T4]()
	t5 := reflect.TypeFor[T5]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	id4 := w.getCompTypeID(t4)
	id5 := w.getCompTypeID(t5)
	
	if id2 == id1 || id3 == id1 || id3 == id2 || id4 == id1 || id4 == id2 || id4 == id3 || id5 == id1 || id5 == id2 || id5 == id3 || id5 == id4 {
		panic("ecs: duplicate component types in SetComponents5")
	}
	meta := &w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]

	var setMask bitmask256
	setMask.set(id1)
	setMask.set(id2)
	setMask.set(id3)
	setMask.set(id4)
	setMask.set(id5)
	

	if a.mask.contains(setMask) {
		// already has all, just set
		p1 := unsafe.Pointer(uintptr(a.compPointers[id1]) + uintptr(meta.index)*a.compSizes[id1])
		*(*T1)(p1) = c1
		p2 := unsafe.Pointer(uintptr(a.compPointers[id2]) + uintptr(meta.index)*a.compSizes[id2])
		*(*T2)(p2) = c2
		p3 := unsafe.Pointer(uintptr(a.compPointers[id3]) + uintptr(meta.index)*a.compSizes[id3])
		*(*T3)(p3) = c3
		p4 := unsafe.Pointer(uintptr(a.compPointers[id4]) + uintptr(meta.index)*a.compSizes[id4])
		*(*T4)(p4) = c4
		p5 := unsafe.Pointer(uintptr(a.compPointers[id5]) + uintptr(meta.index)*a.compSizes[id5])
		*(*T5)(p5) = c5
		
		return
	}

	newMask := a.mask
	newMask.set(id1)
	newMask.set(id2)
	newMask.set(id3)
	newMask.set(id4)
	newMask.set(id5)
	

	var tempSpecs [MaxComponentTypes]compSpec
	count := 0
	for i := uint8(0); i < uint8(w.nextCompTypeID); i++ {
		var bm bitmask256
		bm.set(i)
		if newMask.contains(bm) {
			typ := w.compIDToType[i]
			tempSpecs[count] = compSpec{i, typ, typ.Size()}
			count++
		}
	}
	specs := tempSpecs[:count]
	targetA := w.getOrCreateArchetype(newMask, specs)

	newIdx := targetA.size
	targetA.entityIDs[newIdx] = e
	targetA.size++

	for _, cid := range a.compOrder {
		src := unsafe.Pointer(uintptr(a.compPointers[cid]) + uintptr(meta.index)*a.compSizes[cid])
		dst := unsafe.Pointer(uintptr(targetA.compPointers[cid]) + uintptr(newIdx)*targetA.compSizes[cid])
		memCopy(dst, src, a.compSizes[cid])
	}

	
	{
		var singleMask bitmask256
		singleMask.set(id1)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id1]) + uintptr(newIdx)*targetA.compSizes[id1])
			*(*T1)(dst) = c1
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id2)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id2]) + uintptr(newIdx)*targetA.compSizes[id2])
			*(*T2)(dst) = c2
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id3)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id3]) + uintptr(newIdx)*targetA.compSizes[id3])
			*(*T3)(dst) = c3
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id4)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id4]) + uintptr(newIdx)*targetA.compSizes[id4])
			*(*T4)(dst) = c4
		}
	}
	
	{
		var singleMask bitmask256
		singleMask.set(id5)
		if !a.mask.contains(singleMask) {
			dst := unsafe.Pointer(uintptr(targetA.compPointers[id5]) + uintptr(newIdx)*targetA.compSizes[id5])
			*(*T5)(dst) = c5
		}
	}
	

	w.removeFromArchetype(a, meta)

	meta.archetypeIndex = targetA.index
	meta.index = newIdx
}

// RemoveComponents5 removes the components of type T1, T2, T3, T4, T5 from the entity if present.
func RemoveComponents5[T1 any, T2 any, T3 any, T4 any, T5 any](w *World, e Entity) {
	if !w.IsValid(e) {
		return
	}
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	t4 := reflect.TypeFor[T4]()
	t5 := reflect.TypeFor[T5]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	id4 := w.getCompTypeID(t4)
	id5 := w.getCompTypeID(t5)
	
	if id2 == id1 || id3 == id1 || id3 == id2 || id4 == id1 || id4 == id2 || id4 == id3 || id5 == id1 || id5 == id2 || id5 == id3 || id5 == id4 {
		panic("ecs: duplicate component types in RemoveComponents5")
	}
	meta := &w.metas[e.ID]
	a := w.archetypes[meta.archetypeIndex]

	var removeMask bitmask256
	removeMask.set(id1)
	removeMask.set(id2)
	removeMask.set(id3)
	removeMask.set(id4)
	removeMask.set(id5)
	

	if !a.mask.intersects(removeMask) {
		return
	}

	newMask := a.mask
	newMask.unset(id1)
	newMask.unset(id2)
	newMask.unset(id3)
	newMask.unset(id4)
	newMask.unset(id5)
	

	var tempSpecs [MaxComponentTypes]compSpec
	count := 0
	for i := uint8(0); i < uint8(w.nextCompTypeID); i++ {
		var bm bitmask256
		bm.set(i)
		if newMask.contains(bm) {
			typ := w.compIDToType[i]
			tempSpecs[count] = compSpec{i, typ, typ.Size()}
			count++
		}
	}
	specs := tempSpecs[:count]
	targetA := w.getOrCreateArchetype(newMask, specs)

	newIdx := targetA.size
	targetA.entityIDs[newIdx] = e
	targetA.size++

	for _, cid := range a.compOrder {
		var bm bitmask256
		bm.set(cid)
		if removeMask.contains(bm) {
			continue
		}
		src := unsafe.Pointer(uintptr(a.compPointers[cid]) + uintptr(meta.index)*a.compSizes[cid])
		dst := unsafe.Pointer(uintptr(targetA.compPointers[cid]) + uintptr(newIdx)*targetA.compSizes[cid])
		memCopy(dst, src, a.compSizes[cid])
	}

	w.removeFromArchetype(a, meta)

	meta.archetypeIndex = targetA.index
	meta.index = newIdx
}