// Code generated by go generate; DO NOT EDIT.
package lazyecs

import (
	"reflect"
	"unsafe"
)

// Filter2 provides a fast iterator over entities with components T1, T2.
type Filter2[T1 any, T2 any] struct {
	world          *World
	mask           bitmask256
	id1            uint8
	id2            uint8
	
	matchingArches []*archetype
	lastVersion    uint32
	curMatchIdx    int
	curIdx         int
	curEnt         Entity
}

// NewFilter2 creates a filter for entities with components T1, T2.
func NewFilter2[T1 any, T2 any](w *World) *Filter2[T1, T2] {
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	
	if id2 == id1 {
		panic("ecs: duplicate component types in Filter2")
	}
	var m bitmask256
	m.set(id1)
	m.set(id2)
	
	f := &Filter2[T1, T2]{world: w, mask: m, id1: id1,id2: id2, curMatchIdx: 0, curIdx: -1, matchingArches: make([]*archetype, 0, 4)}
	f.updateMatching()
	return f
}

// updateMatching updates the list of matching archetypes.
func (f *Filter2[T1, T2]) updateMatching() {
	f.matchingArches = f.matchingArches[:0]
	for _, a := range f.world.archetypes {
		if a.mask.contains(f.mask) {
			f.matchingArches = append(f.matchingArches, a)
		}
	}
	f.lastVersion = f.world.archetypeVersion
}

// Reset resets the filter iterator.
func (f *Filter2[T1, T2]) Reset() {
	if f.world.archetypeVersion != f.lastVersion {
		f.updateMatching()
	}
	f.curMatchIdx = 0
	f.curIdx = -1
}

// Next advances to the next entity with the components, returning true if found.
func (f *Filter2[T1, T2]) Next() bool {
	for {
		f.curIdx++
		if f.curMatchIdx >= len(f.matchingArches) {
			return false
		}
		a := f.matchingArches[f.curMatchIdx]
		if f.curIdx >= a.size {
			f.curMatchIdx++
			f.curIdx = -1
			continue
		}
		f.curEnt = a.entityIDs[f.curIdx]
		return true
	}
}

// Entity returns the current entity.
func (f *Filter2[T1, T2]) Entity() Entity {
	return f.curEnt
}

// Get returns pointers to the current components T1, T2.
func (f *Filter2[T1, T2]) Get() (*T1, *T2) {
	a := f.matchingArches[f.curMatchIdx]
	p1 := unsafe.Pointer(uintptr(a.compPointers[f.id1]) + uintptr(f.curIdx)*a.compSizes[f.id1])
	p2 := unsafe.Pointer(uintptr(a.compPointers[f.id2]) + uintptr(f.curIdx)*a.compSizes[f.id2])
	
	return (*T1)(p1), (*T2)(p2)
}// Filter3 provides a fast iterator over entities with components T1, T2, T3.
type Filter3[T1 any, T2 any, T3 any] struct {
	world          *World
	mask           bitmask256
	id1            uint8
	id2            uint8
	id3            uint8
	
	matchingArches []*archetype
	lastVersion    uint32
	curMatchIdx    int
	curIdx         int
	curEnt         Entity
}

// NewFilter3 creates a filter for entities with components T1, T2, T3.
func NewFilter3[T1 any, T2 any, T3 any](w *World) *Filter3[T1, T2, T3] {
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	
	if id2 == id1 || id3 == id1 || id3 == id2 {
		panic("ecs: duplicate component types in Filter3")
	}
	var m bitmask256
	m.set(id1)
	m.set(id2)
	m.set(id3)
	
	f := &Filter3[T1, T2, T3]{world: w, mask: m, id1: id1,id2: id2,id3: id3, curMatchIdx: 0, curIdx: -1, matchingArches: make([]*archetype, 0, 4)}
	f.updateMatching()
	return f
}

// updateMatching updates the list of matching archetypes.
func (f *Filter3[T1, T2, T3]) updateMatching() {
	f.matchingArches = f.matchingArches[:0]
	for _, a := range f.world.archetypes {
		if a.mask.contains(f.mask) {
			f.matchingArches = append(f.matchingArches, a)
		}
	}
	f.lastVersion = f.world.archetypeVersion
}

// Reset resets the filter iterator.
func (f *Filter3[T1, T2, T3]) Reset() {
	if f.world.archetypeVersion != f.lastVersion {
		f.updateMatching()
	}
	f.curMatchIdx = 0
	f.curIdx = -1
}

// Next advances to the next entity with the components, returning true if found.
func (f *Filter3[T1, T2, T3]) Next() bool {
	for {
		f.curIdx++
		if f.curMatchIdx >= len(f.matchingArches) {
			return false
		}
		a := f.matchingArches[f.curMatchIdx]
		if f.curIdx >= a.size {
			f.curMatchIdx++
			f.curIdx = -1
			continue
		}
		f.curEnt = a.entityIDs[f.curIdx]
		return true
	}
}

// Entity returns the current entity.
func (f *Filter3[T1, T2, T3]) Entity() Entity {
	return f.curEnt
}

// Get returns pointers to the current components T1, T2, T3.
func (f *Filter3[T1, T2, T3]) Get() (*T1, *T2, *T3) {
	a := f.matchingArches[f.curMatchIdx]
	p1 := unsafe.Pointer(uintptr(a.compPointers[f.id1]) + uintptr(f.curIdx)*a.compSizes[f.id1])
	p2 := unsafe.Pointer(uintptr(a.compPointers[f.id2]) + uintptr(f.curIdx)*a.compSizes[f.id2])
	p3 := unsafe.Pointer(uintptr(a.compPointers[f.id3]) + uintptr(f.curIdx)*a.compSizes[f.id3])
	
	return (*T1)(p1), (*T2)(p2), (*T3)(p3)
}// Filter4 provides a fast iterator over entities with components T1, T2, T3, T4.
type Filter4[T1 any, T2 any, T3 any, T4 any] struct {
	world          *World
	mask           bitmask256
	id1            uint8
	id2            uint8
	id3            uint8
	id4            uint8
	
	matchingArches []*archetype
	lastVersion    uint32
	curMatchIdx    int
	curIdx         int
	curEnt         Entity
}

// NewFilter4 creates a filter for entities with components T1, T2, T3, T4.
func NewFilter4[T1 any, T2 any, T3 any, T4 any](w *World) *Filter4[T1, T2, T3, T4] {
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	t4 := reflect.TypeFor[T4]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	id4 := w.getCompTypeID(t4)
	
	if id2 == id1 || id3 == id1 || id3 == id2 || id4 == id1 || id4 == id2 || id4 == id3 {
		panic("ecs: duplicate component types in Filter4")
	}
	var m bitmask256
	m.set(id1)
	m.set(id2)
	m.set(id3)
	m.set(id4)
	
	f := &Filter4[T1, T2, T3, T4]{world: w, mask: m, id1: id1,id2: id2,id3: id3,id4: id4, curMatchIdx: 0, curIdx: -1, matchingArches: make([]*archetype, 0, 4)}
	f.updateMatching()
	return f
}

// updateMatching updates the list of matching archetypes.
func (f *Filter4[T1, T2, T3, T4]) updateMatching() {
	f.matchingArches = f.matchingArches[:0]
	for _, a := range f.world.archetypes {
		if a.mask.contains(f.mask) {
			f.matchingArches = append(f.matchingArches, a)
		}
	}
	f.lastVersion = f.world.archetypeVersion
}

// Reset resets the filter iterator.
func (f *Filter4[T1, T2, T3, T4]) Reset() {
	if f.world.archetypeVersion != f.lastVersion {
		f.updateMatching()
	}
	f.curMatchIdx = 0
	f.curIdx = -1
}

// Next advances to the next entity with the components, returning true if found.
func (f *Filter4[T1, T2, T3, T4]) Next() bool {
	for {
		f.curIdx++
		if f.curMatchIdx >= len(f.matchingArches) {
			return false
		}
		a := f.matchingArches[f.curMatchIdx]
		if f.curIdx >= a.size {
			f.curMatchIdx++
			f.curIdx = -1
			continue
		}
		f.curEnt = a.entityIDs[f.curIdx]
		return true
	}
}

// Entity returns the current entity.
func (f *Filter4[T1, T2, T3, T4]) Entity() Entity {
	return f.curEnt
}

// Get returns pointers to the current components T1, T2, T3, T4.
func (f *Filter4[T1, T2, T3, T4]) Get() (*T1, *T2, *T3, *T4) {
	a := f.matchingArches[f.curMatchIdx]
	p1 := unsafe.Pointer(uintptr(a.compPointers[f.id1]) + uintptr(f.curIdx)*a.compSizes[f.id1])
	p2 := unsafe.Pointer(uintptr(a.compPointers[f.id2]) + uintptr(f.curIdx)*a.compSizes[f.id2])
	p3 := unsafe.Pointer(uintptr(a.compPointers[f.id3]) + uintptr(f.curIdx)*a.compSizes[f.id3])
	p4 := unsafe.Pointer(uintptr(a.compPointers[f.id4]) + uintptr(f.curIdx)*a.compSizes[f.id4])
	
	return (*T1)(p1), (*T2)(p2), (*T3)(p3), (*T4)(p4)
}// Filter5 provides a fast iterator over entities with components T1, T2, T3, T4, T5.
type Filter5[T1 any, T2 any, T3 any, T4 any, T5 any] struct {
	world          *World
	mask           bitmask256
	id1            uint8
	id2            uint8
	id3            uint8
	id4            uint8
	id5            uint8
	
	matchingArches []*archetype
	lastVersion    uint32
	curMatchIdx    int
	curIdx         int
	curEnt         Entity
}

// NewFilter5 creates a filter for entities with components T1, T2, T3, T4, T5.
func NewFilter5[T1 any, T2 any, T3 any, T4 any, T5 any](w *World) *Filter5[T1, T2, T3, T4, T5] {
	t1 := reflect.TypeFor[T1]()
	t2 := reflect.TypeFor[T2]()
	t3 := reflect.TypeFor[T3]()
	t4 := reflect.TypeFor[T4]()
	t5 := reflect.TypeFor[T5]()
	
	id1 := w.getCompTypeID(t1)
	id2 := w.getCompTypeID(t2)
	id3 := w.getCompTypeID(t3)
	id4 := w.getCompTypeID(t4)
	id5 := w.getCompTypeID(t5)
	
	if id2 == id1 || id3 == id1 || id3 == id2 || id4 == id1 || id4 == id2 || id4 == id3 || id5 == id1 || id5 == id2 || id5 == id3 || id5 == id4 {
		panic("ecs: duplicate component types in Filter5")
	}
	var m bitmask256
	m.set(id1)
	m.set(id2)
	m.set(id3)
	m.set(id4)
	m.set(id5)
	
	f := &Filter5[T1, T2, T3, T4, T5]{world: w, mask: m, id1: id1,id2: id2,id3: id3,id4: id4,id5: id5, curMatchIdx: 0, curIdx: -1, matchingArches: make([]*archetype, 0, 4)}
	f.updateMatching()
	return f
}

// updateMatching updates the list of matching archetypes.
func (f *Filter5[T1, T2, T3, T4, T5]) updateMatching() {
	f.matchingArches = f.matchingArches[:0]
	for _, a := range f.world.archetypes {
		if a.mask.contains(f.mask) {
			f.matchingArches = append(f.matchingArches, a)
		}
	}
	f.lastVersion = f.world.archetypeVersion
}

// Reset resets the filter iterator.
func (f *Filter5[T1, T2, T3, T4, T5]) Reset() {
	if f.world.archetypeVersion != f.lastVersion {
		f.updateMatching()
	}
	f.curMatchIdx = 0
	f.curIdx = -1
}

// Next advances to the next entity with the components, returning true if found.
func (f *Filter5[T1, T2, T3, T4, T5]) Next() bool {
	for {
		f.curIdx++
		if f.curMatchIdx >= len(f.matchingArches) {
			return false
		}
		a := f.matchingArches[f.curMatchIdx]
		if f.curIdx >= a.size {
			f.curMatchIdx++
			f.curIdx = -1
			continue
		}
		f.curEnt = a.entityIDs[f.curIdx]
		return true
	}
}

// Entity returns the current entity.
func (f *Filter5[T1, T2, T3, T4, T5]) Entity() Entity {
	return f.curEnt
}

// Get returns pointers to the current components T1, T2, T3, T4, T5.
func (f *Filter5[T1, T2, T3, T4, T5]) Get() (*T1, *T2, *T3, *T4, *T5) {
	a := f.matchingArches[f.curMatchIdx]
	p1 := unsafe.Pointer(uintptr(a.compPointers[f.id1]) + uintptr(f.curIdx)*a.compSizes[f.id1])
	p2 := unsafe.Pointer(uintptr(a.compPointers[f.id2]) + uintptr(f.curIdx)*a.compSizes[f.id2])
	p3 := unsafe.Pointer(uintptr(a.compPointers[f.id3]) + uintptr(f.curIdx)*a.compSizes[f.id3])
	p4 := unsafe.Pointer(uintptr(a.compPointers[f.id4]) + uintptr(f.curIdx)*a.compSizes[f.id4])
	p5 := unsafe.Pointer(uintptr(a.compPointers[f.id5]) + uintptr(f.curIdx)*a.compSizes[f.id5])
	
	return (*T1)(p1), (*T2)(p2), (*T3)(p3), (*T4)(p4), (*T5)(p5)
}