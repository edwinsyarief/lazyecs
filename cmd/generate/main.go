package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

// ComponentInfo holds all the variable names for a single component,
// making it easy to use in templates.
type ComponentInfo struct {
	TypeName       string // T1, T2...
	VarName        string // v1, v2...
	BuilderVarName string // comp1, comp2...
	IDName         string // id1, id2...
	SizeName       string // size1, size2...
	OKName         string // ok1, ok2...
	SlotName       string // slot1, slot2...
	BytesName      string // bytes1, bytes2...
	SrcName        string // src1, src2...
	BaseName       string // base1, base2...
	StrideName     string // stride1, stride2...
	PtrName        string // p1, p2...
	Index          int
}

// TemplateData holds the placeholders for a single N-ary function variant.
type TemplateData struct {
	Types               string // T1 any, T2 any
	TypeVars            string // T1, T2
	Vars                string // v1 T1, v2 T2
	BuilderVars         string // comp1 T1, comp2 T2
	IDs                 string // id1, id2
	OKIDs               string // !ok1 || !ok2
	DuplicateIDs        string // id1 == id2 || id1 == id3 ...
	ReturnTypes         string // *T1, *T2
	ReturnSinglePtrs    string // *T1, *T2
	ReturnPtrs          string // (*T1)(p1), (*T2)(p2)
	ReturnVars          string // c1, c2
	ReturnNil           string // nil, nil
	SlotCheckCondition  string // slot1 == -1 || slot2 == -1
	BatchRes            string // []*T1, []*T2
	ReturnBatchRes      string // res1, res2
	ReturnPtrsFromBytes string // (*T1)(unsafe.Pointer(&bytes1[...])), ...
	MaskCheck           string
	BuilderMaskCheck    string
	HasAll              string
	HasNone             string
	IsRemovedID         string
	Components          []ComponentInfo
	N                   int
}

func main() {
	maxN := 6
	if len(os.Args) > 1 {
		n, err := strconv.Atoi(os.Args[1])
		if err != nil {
			fmt.Println("Invalid number provided:", os.Args[1])
			os.Exit(1)
		}
		maxN = n
	}
	templates := []string{"builder_generated.go.tpl", "world_api_generated.go.tpl", "filter_generated.go.tpl"}
	templateDir := "templates"
	outputDir := "."
	fmt.Printf("Generating code for N=1 to %d...\n", maxN)
	for _, tplFile := range templates {
		tplPath := filepath.Join(templateDir, tplFile)
		outPath := filepath.Join(outputDir, strings.TrimSuffix(tplFile, ".tpl"))
		outFile, err := os.Create(outPath)
		if err != nil {
			panic(err)
		}
		_, _ = outFile.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
		_, _ = outFile.WriteString("package lazyecs\n\n")
		_, _ = outFile.WriteString("import (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\n")
		tpl, err := template.ParseFiles(tplPath)
		if err != nil {
			panic(err)
		}
		for i := 2; i <= maxN; i++ {
			data := buildTemplateData(i)
			var buf bytes.Buffer
			err := tpl.Execute(&buf, data)
			if err != nil {
				panic(fmt.Sprintf("Error executing template %s for N=%d: %v", tplFile, i, err))
			}
			_, _ = outFile.Write(buf.Bytes())
			_, _ = outFile.WriteString("\n\n")
		}
		outFile.Close()
	}
	fmt.Println("Code generation complete.")
}

func buildTemplateData(n int) TemplateData {
	components := make([]ComponentInfo, n)
	var types, typeVars, vars, builderVars, ids, okIDs, returnTypes, returnSinglePtrs, returnPtrs, returnVars, returnNil, slotCheck, batchRes, returnBatchRes, returnFromBytes []string
	var duplicateIDs, maskChecks, builderMaskChecks, hasAll, hasNone, isRemovedIDs []string
	for i := 1; i <= n; i++ {
		is := strconv.Itoa(i)
		ci := ComponentInfo{
			Index:          i,
			TypeName:       "T" + is,
			VarName:        "v" + is,
			BuilderVarName: "comp" + is,
			IDName:         "id" + is,
			SizeName:       "size" + is,
			OKName:         "ok" + is,
			SlotName:       "slot" + is,
			BytesName:      "bytes" + is,
			SrcName:        "src" + is,
			BaseName:       "base" + is,
			StrideName:     "stride" + is,
			PtrName:        "ptr" + is,
		}
		components[i-1] = ci
		types = append(types, ci.TypeName+" any")
		typeVars = append(typeVars, ci.TypeName)
		vars = append(vars, ci.VarName+" "+ci.TypeName)
		builderVars = append(builderVars, ci.BuilderVarName+" "+ci.TypeName)
		ids = append(ids, ci.IDName)
		okIDs = append(okIDs, "!"+ci.OKName)
		returnTypes = append(returnTypes, "*"+ci.TypeName)
		returnSinglePtrs = append(returnSinglePtrs, "*"+ci.TypeName)
		returnPtrs = append(returnPtrs, "(*"+ci.TypeName+")("+ci.PtrName+")")
		returnVars = append(returnVars, ci.VarName)
		returnNil = append(returnNil, "nil")
		slotCheck = append(slotCheck, ci.SlotName+" == -1")
		batchRes = append(batchRes, "[]*"+ci.TypeName)
		returnBatchRes = append(returnBatchRes, "res"+is)
		returnFromBytes = append(returnFromBytes, "(*"+ci.TypeName+")(unsafe.Pointer(&"+ci.BytesName+"[meta.Index*"+ci.SizeName+"]))")
		maskChecks = append(maskChecks, fmt.Sprintf("(a.mask[i%s]&(uint64(1)<<uint64(o%s))) == 0", is, is))
		builderMaskChecks = append(builderMaskChecks, fmt.Sprintf("(a.mask[i%s]&(uint64(1)<<uint64(o%s))) == 0", is, is))
		hasAll = append(hasAll, "has"+is)
		hasNone = append(hasNone, "!has"+is)
		isRemovedIDs = append(isRemovedIDs, "cid == id"+is)
		for j := 1; j < i; j++ {
			js := strconv.Itoa(j)
			duplicateIDs = append(duplicateIDs, "id"+is+" == id"+js)
		}
	}

	return TemplateData{
		N:                   n,
		Components:          components,
		Types:               strings.Join(types, ", "),
		TypeVars:            strings.Join(typeVars, ", "),
		Vars:                strings.Join(vars, ", "),
		BuilderVars:         strings.Join(builderVars, ", "),
		IDs:                 strings.Join(ids, ", "),
		OKIDs:               strings.Join(okIDs, " || "),
		DuplicateIDs:        strings.Join(duplicateIDs, " || "),
		ReturnTypes:         strings.Join(returnTypes, ", "),
		ReturnSinglePtrs:    strings.Join(returnSinglePtrs, ", "),
		ReturnPtrs:          strings.Join(returnPtrs, ", "),
		ReturnVars:          strings.Join(returnVars, ", "),
		ReturnNil:           strings.Join(returnNil, ", "),
		SlotCheckCondition:  strings.Join(slotCheck, " || "),
		BatchRes:            strings.Join(batchRes, ", "),
		ReturnBatchRes:      strings.Join(returnBatchRes, ", "),
		ReturnPtrsFromBytes: strings.Join(returnFromBytes, ", "),
		MaskCheck:           strings.Join(maskChecks, " || "),
		BuilderMaskCheck:    strings.Join(builderMaskChecks, " || "),
		HasAll:              strings.Join(hasAll, " && "),
		HasNone:             strings.Join(hasNone, " && "),
		IsRemovedID:         strings.Join(isRemovedIDs, " || "),
	}
}
