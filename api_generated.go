// Code generated by go generate; DO NOT EDIT.
package lazyecs

import "unsafe"
// AddComponent2 adds 2 components to an entity if not already present.
// It returns pointers to the components (existing or new) and a boolean indicating success.
func AddComponent2[T1 any, T2 any](w *World, e Entity) (*T1, *T2, bool) {
	if int(e.ID) >= len(w.entitiesSlice) {
		return nil, nil, false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return nil, nil, false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	
	if !ok1 || !ok2 {
		return nil, nil, false
	}
	size1 := int(componentSizes[id1])
	size2 := int(componentSizes[id2])
	
	oldArch := meta.Archetype
	addMask := makeMask2(id1, id2)
	if includesAll(oldArch.mask, addMask) {
		slot1 := oldArch.getSlot(id1)
		slot2 := oldArch.getSlot(id2)
		
		if slot1 == -1 || slot2 == -1 {
			return nil, nil, false
		}
		bytes1 := oldArch.componentData[slot1]
		if meta.Index*size1 >= len(bytes1) {
			return nil, nil, false
		}
		bytes2 := oldArch.componentData[slot2]
		if meta.Index*size2 >= len(bytes2) {
			return nil, nil, false
		}
		
		return (*T1)(unsafe.Pointer(&bytes1[meta.Index*size1])), (*T2)(unsafe.Pointer(&bytes2[meta.Index*size2])), true
	}

	newMask := orMask(oldArch.mask, addMask)

	var transition Transition
	addMap, ok := w.addTransitions[oldArch]
	if ok {
		if tr, ok := addMap[addMask]; ok {
			transition = tr
		}
	}
	var newArch *Archetype
	if transition.target == nil {
		newArch = w.getOrCreateArchetype(newMask)
		copies := make([]CopyOp, 0, len(oldArch.componentIDs))
		for from, id := range oldArch.componentIDs {
			to := newArch.getSlot(id)
			if to >= 0 {
				copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
			}
		}
		transition = Transition{target: newArch, copies: copies}
		if _, ok := w.addTransitions[oldArch]; !ok {
			w.addTransitions[oldArch] = make(map[maskType]Transition)
		}
		w.addTransitions[oldArch][addMask] = transition
	} else {
		newArch = transition.target
	}

	oldIndex := meta.Index
	newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

	ids := []ComponentID{ id1, id2 }
	for _, id := range ids {
		if !oldArch.mask.has(id) {
			idx := newArch.getSlot(id)
			if idx == -1 {
				return nil, nil, false
			}
			bytes := newArch.componentData[idx]
			bytes = extendByteSlice(bytes, int(componentSizes[id]))
			newArch.componentData[idx] = bytes
		}
	}

	meta.Archetype = newArch
	meta.Index = newIndex
	w.entitiesSlice[e.ID] = meta

	w.removeEntityFromArchetype(e, oldArch, oldIndex)

	slot1 := newArch.getSlot(id1)
	slot2 := newArch.getSlot(id2)
	
	if slot1 == -1 || slot2 == -1 {
		return nil, nil, false
	}
	bytes1 := newArch.componentData[slot1]
	bytes2 := newArch.componentData[slot2]
	
	return (*T1)(unsafe.Pointer(&bytes1[newIndex*size1])), (*T2)(unsafe.Pointer(&bytes2[newIndex*size2])), true
}

// SetComponent2 sets 2 components for an entity.
// If any component is missing, it adds them; otherwise, updates existing ones.
// It returns a boolean indicating success.
func SetComponent2[T1 any, T2 any](w *World, e Entity, c1 T1, c2 T2) bool {
	if int(e.ID) >= len(w.entitiesSlice) {
		return false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	
	if !ok1 || !ok2 {
		return false
	}
	size1 := int(componentSizes[id1])
	size2 := int(componentSizes[id2])
	
	src1 := unsafe.Slice((*byte)(unsafe.Pointer(&c1)), size1)
	src2 := unsafe.Slice((*byte)(unsafe.Pointer(&c2)), size2)
	
	oldArch := meta.Archetype
	setMask := makeMask2(id1, id2)
	if includesAll(oldArch.mask, setMask) {
		slot1 := oldArch.getSlot(id1)
		slot2 := oldArch.getSlot(id2)
		
		if slot1 == -1 || slot2 == -1 {
			return false
		}
		bytes1 := oldArch.componentData[slot1]
		if meta.Index*size1 >= len(bytes1) {
			return false
		}
		copy(bytes1[meta.Index*size1:(meta.Index+1)*size1], src1)
		bytes2 := oldArch.componentData[slot2]
		if meta.Index*size2 >= len(bytes2) {
			return false
		}
		copy(bytes2[meta.Index*size2:(meta.Index+1)*size2], src2)
		
		return true
	} else {
		newMask := orMask(oldArch.mask, setMask)
		var transition Transition
		addMap, ok := w.addTransitions[oldArch]
		if ok {
			if tr, ok := addMap[setMask]; ok {
				transition = tr
			}
		}
		var newArch *Archetype
		if transition.target == nil {
			newArch = w.getOrCreateArchetype(newMask)
			copies := make([]CopyOp, 0, len(oldArch.componentIDs))
			for from, id := range oldArch.componentIDs {
				to := newArch.getSlot(id)
				if to >= 0 {
					copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
				}
			}
			transition = Transition{target: newArch, copies: copies}
			if _, ok := w.addTransitions[oldArch]; !ok {
				w.addTransitions[oldArch] = make(map[maskType]Transition)
			}
			w.addTransitions[oldArch][setMask] = transition
		} else {
			newArch = transition.target
		}

		oldIndex := meta.Index
		newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

		ids := []ComponentID{ id1, id2 }
		srcs := [][]byte{ src1, src2 }
		sizes := []int{ size1, size2 }
		for i, id := range ids {
			idx := newArch.getSlot(id)
			if idx == -1 {
				return false
			}
			bytes := newArch.componentData[idx]
			if oldArch.mask.has(id) {
				copy(bytes[newIndex*sizes[i]:(newIndex+1)*sizes[i]], srcs[i])
			} else {
				bytes = extendByteSlice(bytes, sizes[i])
				copy(bytes[len(bytes)-sizes[i]:], srcs[i])
				newArch.componentData[idx] = bytes
			}
		}

		meta.Archetype = newArch
		meta.Index = newIndex
		w.entitiesSlice[e.ID] = meta

		w.removeEntityFromArchetype(e, oldArch, oldIndex)
		return true
	}
}

// RemoveComponent2 removes 2 components from an entity if present.
// It returns a boolean indicating success.
func RemoveComponent2[T1 any, T2 any](w *World, e Entity) bool {
	if int(e.ID) >= len(w.entitiesSlice) {
		return false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	
	if !ok1 || !ok2 {
		return false
	}

	oldArch := meta.Archetype
	removeMask := makeMask2(id1, id2)
	if !intersects(oldArch.mask, removeMask) {
		return true
	}

	oldIndex := meta.Index

	newMask := andNotMask(oldArch.mask, removeMask)

	var transition Transition
	removeMap, ok := w.removeTransitions[oldArch]
	if ok {
		if tr, ok := removeMap[removeMask]; ok {
			transition = tr
		}
	}
	var newArch *Archetype
	if transition.target == nil {
		newArch = w.getOrCreateArchetype(newMask)
		copies := make([]CopyOp, 0, len(oldArch.componentIDs))
		for from, id := range oldArch.componentIDs {
			if removeMask.has(id) {
				continue
			}
			to := newArch.getSlot(id)
			if to >= 0 {
				copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
			}
		}
		transition = Transition{target: newArch, copies: copies}
		if _, ok := w.removeTransitions[oldArch]; !ok {
			w.removeTransitions[oldArch] = make(map[maskType]Transition)
		}
		w.removeTransitions[oldArch][removeMask] = transition
	} else {
		newArch = transition.target
	}

	newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

	meta.Archetype = newArch
	meta.Index = newIndex
	w.entitiesSlice[e.ID] = meta

	w.removeEntityFromArchetype(e, oldArch, oldIndex)

	return true
}// AddComponent3 adds 3 components to an entity if not already present.
// It returns pointers to the components (existing or new) and a boolean indicating success.
func AddComponent3[T1 any, T2 any, T3 any](w *World, e Entity) (*T1, *T2, *T3, bool) {
	if int(e.ID) >= len(w.entitiesSlice) {
		return nil, nil, nil, false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return nil, nil, nil, false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	
	if !ok1 || !ok2 || !ok3 {
		return nil, nil, nil, false
	}
	size1 := int(componentSizes[id1])
	size2 := int(componentSizes[id2])
	size3 := int(componentSizes[id3])
	
	oldArch := meta.Archetype
	addMask := makeMask3(id1, id2, id3)
	if includesAll(oldArch.mask, addMask) {
		slot1 := oldArch.getSlot(id1)
		slot2 := oldArch.getSlot(id2)
		slot3 := oldArch.getSlot(id3)
		
		if slot1 == -1 || slot2 == -1 || slot3 == -1 {
			return nil, nil, nil, false
		}
		bytes1 := oldArch.componentData[slot1]
		if meta.Index*size1 >= len(bytes1) {
			return nil, nil, nil, false
		}
		bytes2 := oldArch.componentData[slot2]
		if meta.Index*size2 >= len(bytes2) {
			return nil, nil, nil, false
		}
		bytes3 := oldArch.componentData[slot3]
		if meta.Index*size3 >= len(bytes3) {
			return nil, nil, nil, false
		}
		
		return (*T1)(unsafe.Pointer(&bytes1[meta.Index*size1])), (*T2)(unsafe.Pointer(&bytes2[meta.Index*size2])), (*T3)(unsafe.Pointer(&bytes3[meta.Index*size3])), true
	}

	newMask := orMask(oldArch.mask, addMask)

	var transition Transition
	addMap, ok := w.addTransitions[oldArch]
	if ok {
		if tr, ok := addMap[addMask]; ok {
			transition = tr
		}
	}
	var newArch *Archetype
	if transition.target == nil {
		newArch = w.getOrCreateArchetype(newMask)
		copies := make([]CopyOp, 0, len(oldArch.componentIDs))
		for from, id := range oldArch.componentIDs {
			to := newArch.getSlot(id)
			if to >= 0 {
				copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
			}
		}
		transition = Transition{target: newArch, copies: copies}
		if _, ok := w.addTransitions[oldArch]; !ok {
			w.addTransitions[oldArch] = make(map[maskType]Transition)
		}
		w.addTransitions[oldArch][addMask] = transition
	} else {
		newArch = transition.target
	}

	oldIndex := meta.Index
	newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

	ids := []ComponentID{ id1, id2, id3 }
	for _, id := range ids {
		if !oldArch.mask.has(id) {
			idx := newArch.getSlot(id)
			if idx == -1 {
				return nil, nil, nil, false
			}
			bytes := newArch.componentData[idx]
			bytes = extendByteSlice(bytes, int(componentSizes[id]))
			newArch.componentData[idx] = bytes
		}
	}

	meta.Archetype = newArch
	meta.Index = newIndex
	w.entitiesSlice[e.ID] = meta

	w.removeEntityFromArchetype(e, oldArch, oldIndex)

	slot1 := newArch.getSlot(id1)
	slot2 := newArch.getSlot(id2)
	slot3 := newArch.getSlot(id3)
	
	if slot1 == -1 || slot2 == -1 || slot3 == -1 {
		return nil, nil, nil, false
	}
	bytes1 := newArch.componentData[slot1]
	bytes2 := newArch.componentData[slot2]
	bytes3 := newArch.componentData[slot3]
	
	return (*T1)(unsafe.Pointer(&bytes1[newIndex*size1])), (*T2)(unsafe.Pointer(&bytes2[newIndex*size2])), (*T3)(unsafe.Pointer(&bytes3[newIndex*size3])), true
}

// SetComponent3 sets 3 components for an entity.
// If any component is missing, it adds them; otherwise, updates existing ones.
// It returns a boolean indicating success.
func SetComponent3[T1 any, T2 any, T3 any](w *World, e Entity, c1 T1, c2 T2, c3 T3) bool {
	if int(e.ID) >= len(w.entitiesSlice) {
		return false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	
	if !ok1 || !ok2 || !ok3 {
		return false
	}
	size1 := int(componentSizes[id1])
	size2 := int(componentSizes[id2])
	size3 := int(componentSizes[id3])
	
	src1 := unsafe.Slice((*byte)(unsafe.Pointer(&c1)), size1)
	src2 := unsafe.Slice((*byte)(unsafe.Pointer(&c2)), size2)
	src3 := unsafe.Slice((*byte)(unsafe.Pointer(&c3)), size3)
	
	oldArch := meta.Archetype
	setMask := makeMask3(id1, id2, id3)
	if includesAll(oldArch.mask, setMask) {
		slot1 := oldArch.getSlot(id1)
		slot2 := oldArch.getSlot(id2)
		slot3 := oldArch.getSlot(id3)
		
		if slot1 == -1 || slot2 == -1 || slot3 == -1 {
			return false
		}
		bytes1 := oldArch.componentData[slot1]
		if meta.Index*size1 >= len(bytes1) {
			return false
		}
		copy(bytes1[meta.Index*size1:(meta.Index+1)*size1], src1)
		bytes2 := oldArch.componentData[slot2]
		if meta.Index*size2 >= len(bytes2) {
			return false
		}
		copy(bytes2[meta.Index*size2:(meta.Index+1)*size2], src2)
		bytes3 := oldArch.componentData[slot3]
		if meta.Index*size3 >= len(bytes3) {
			return false
		}
		copy(bytes3[meta.Index*size3:(meta.Index+1)*size3], src3)
		
		return true
	} else {
		newMask := orMask(oldArch.mask, setMask)
		var transition Transition
		addMap, ok := w.addTransitions[oldArch]
		if ok {
			if tr, ok := addMap[setMask]; ok {
				transition = tr
			}
		}
		var newArch *Archetype
		if transition.target == nil {
			newArch = w.getOrCreateArchetype(newMask)
			copies := make([]CopyOp, 0, len(oldArch.componentIDs))
			for from, id := range oldArch.componentIDs {
				to := newArch.getSlot(id)
				if to >= 0 {
					copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
				}
			}
			transition = Transition{target: newArch, copies: copies}
			if _, ok := w.addTransitions[oldArch]; !ok {
				w.addTransitions[oldArch] = make(map[maskType]Transition)
			}
			w.addTransitions[oldArch][setMask] = transition
		} else {
			newArch = transition.target
		}

		oldIndex := meta.Index
		newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

		ids := []ComponentID{ id1, id2, id3 }
		srcs := [][]byte{ src1, src2, src3 }
		sizes := []int{ size1, size2, size3 }
		for i, id := range ids {
			idx := newArch.getSlot(id)
			if idx == -1 {
				return false
			}
			bytes := newArch.componentData[idx]
			if oldArch.mask.has(id) {
				copy(bytes[newIndex*sizes[i]:(newIndex+1)*sizes[i]], srcs[i])
			} else {
				bytes = extendByteSlice(bytes, sizes[i])
				copy(bytes[len(bytes)-sizes[i]:], srcs[i])
				newArch.componentData[idx] = bytes
			}
		}

		meta.Archetype = newArch
		meta.Index = newIndex
		w.entitiesSlice[e.ID] = meta

		w.removeEntityFromArchetype(e, oldArch, oldIndex)
		return true
	}
}

// RemoveComponent3 removes 3 components from an entity if present.
// It returns a boolean indicating success.
func RemoveComponent3[T1 any, T2 any, T3 any](w *World, e Entity) bool {
	if int(e.ID) >= len(w.entitiesSlice) {
		return false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	
	if !ok1 || !ok2 || !ok3 {
		return false
	}

	oldArch := meta.Archetype
	removeMask := makeMask3(id1, id2, id3)
	if !intersects(oldArch.mask, removeMask) {
		return true
	}

	oldIndex := meta.Index

	newMask := andNotMask(oldArch.mask, removeMask)

	var transition Transition
	removeMap, ok := w.removeTransitions[oldArch]
	if ok {
		if tr, ok := removeMap[removeMask]; ok {
			transition = tr
		}
	}
	var newArch *Archetype
	if transition.target == nil {
		newArch = w.getOrCreateArchetype(newMask)
		copies := make([]CopyOp, 0, len(oldArch.componentIDs))
		for from, id := range oldArch.componentIDs {
			if removeMask.has(id) {
				continue
			}
			to := newArch.getSlot(id)
			if to >= 0 {
				copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
			}
		}
		transition = Transition{target: newArch, copies: copies}
		if _, ok := w.removeTransitions[oldArch]; !ok {
			w.removeTransitions[oldArch] = make(map[maskType]Transition)
		}
		w.removeTransitions[oldArch][removeMask] = transition
	} else {
		newArch = transition.target
	}

	newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

	meta.Archetype = newArch
	meta.Index = newIndex
	w.entitiesSlice[e.ID] = meta

	w.removeEntityFromArchetype(e, oldArch, oldIndex)

	return true
}// AddComponent4 adds 4 components to an entity if not already present.
// It returns pointers to the components (existing or new) and a boolean indicating success.
func AddComponent4[T1 any, T2 any, T3 any, T4 any](w *World, e Entity) (*T1, *T2, *T3, *T4, bool) {
	if int(e.ID) >= len(w.entitiesSlice) {
		return nil, nil, nil, nil, false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return nil, nil, nil, nil, false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	id4, ok4 := TryGetID[T4]()
	
	if !ok1 || !ok2 || !ok3 || !ok4 {
		return nil, nil, nil, nil, false
	}
	size1 := int(componentSizes[id1])
	size2 := int(componentSizes[id2])
	size3 := int(componentSizes[id3])
	size4 := int(componentSizes[id4])
	
	oldArch := meta.Archetype
	addMask := makeMask4(id1, id2, id3, id4)
	if includesAll(oldArch.mask, addMask) {
		slot1 := oldArch.getSlot(id1)
		slot2 := oldArch.getSlot(id2)
		slot3 := oldArch.getSlot(id3)
		slot4 := oldArch.getSlot(id4)
		
		if slot1 == -1 || slot2 == -1 || slot3 == -1 || slot4 == -1 {
			return nil, nil, nil, nil, false
		}
		bytes1 := oldArch.componentData[slot1]
		if meta.Index*size1 >= len(bytes1) {
			return nil, nil, nil, nil, false
		}
		bytes2 := oldArch.componentData[slot2]
		if meta.Index*size2 >= len(bytes2) {
			return nil, nil, nil, nil, false
		}
		bytes3 := oldArch.componentData[slot3]
		if meta.Index*size3 >= len(bytes3) {
			return nil, nil, nil, nil, false
		}
		bytes4 := oldArch.componentData[slot4]
		if meta.Index*size4 >= len(bytes4) {
			return nil, nil, nil, nil, false
		}
		
		return (*T1)(unsafe.Pointer(&bytes1[meta.Index*size1])), (*T2)(unsafe.Pointer(&bytes2[meta.Index*size2])), (*T3)(unsafe.Pointer(&bytes3[meta.Index*size3])), (*T4)(unsafe.Pointer(&bytes4[meta.Index*size4])), true
	}

	newMask := orMask(oldArch.mask, addMask)

	var transition Transition
	addMap, ok := w.addTransitions[oldArch]
	if ok {
		if tr, ok := addMap[addMask]; ok {
			transition = tr
		}
	}
	var newArch *Archetype
	if transition.target == nil {
		newArch = w.getOrCreateArchetype(newMask)
		copies := make([]CopyOp, 0, len(oldArch.componentIDs))
		for from, id := range oldArch.componentIDs {
			to := newArch.getSlot(id)
			if to >= 0 {
				copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
			}
		}
		transition = Transition{target: newArch, copies: copies}
		if _, ok := w.addTransitions[oldArch]; !ok {
			w.addTransitions[oldArch] = make(map[maskType]Transition)
		}
		w.addTransitions[oldArch][addMask] = transition
	} else {
		newArch = transition.target
	}

	oldIndex := meta.Index
	newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

	ids := []ComponentID{ id1, id2, id3, id4 }
	for _, id := range ids {
		if !oldArch.mask.has(id) {
			idx := newArch.getSlot(id)
			if idx == -1 {
				return nil, nil, nil, nil, false
			}
			bytes := newArch.componentData[idx]
			bytes = extendByteSlice(bytes, int(componentSizes[id]))
			newArch.componentData[idx] = bytes
		}
	}

	meta.Archetype = newArch
	meta.Index = newIndex
	w.entitiesSlice[e.ID] = meta

	w.removeEntityFromArchetype(e, oldArch, oldIndex)

	slot1 := newArch.getSlot(id1)
	slot2 := newArch.getSlot(id2)
	slot3 := newArch.getSlot(id3)
	slot4 := newArch.getSlot(id4)
	
	if slot1 == -1 || slot2 == -1 || slot3 == -1 || slot4 == -1 {
		return nil, nil, nil, nil, false
	}
	bytes1 := newArch.componentData[slot1]
	bytes2 := newArch.componentData[slot2]
	bytes3 := newArch.componentData[slot3]
	bytes4 := newArch.componentData[slot4]
	
	return (*T1)(unsafe.Pointer(&bytes1[newIndex*size1])), (*T2)(unsafe.Pointer(&bytes2[newIndex*size2])), (*T3)(unsafe.Pointer(&bytes3[newIndex*size3])), (*T4)(unsafe.Pointer(&bytes4[newIndex*size4])), true
}

// SetComponent4 sets 4 components for an entity.
// If any component is missing, it adds them; otherwise, updates existing ones.
// It returns a boolean indicating success.
func SetComponent4[T1 any, T2 any, T3 any, T4 any](w *World, e Entity, c1 T1, c2 T2, c3 T3, c4 T4) bool {
	if int(e.ID) >= len(w.entitiesSlice) {
		return false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	id4, ok4 := TryGetID[T4]()
	
	if !ok1 || !ok2 || !ok3 || !ok4 {
		return false
	}
	size1 := int(componentSizes[id1])
	size2 := int(componentSizes[id2])
	size3 := int(componentSizes[id3])
	size4 := int(componentSizes[id4])
	
	src1 := unsafe.Slice((*byte)(unsafe.Pointer(&c1)), size1)
	src2 := unsafe.Slice((*byte)(unsafe.Pointer(&c2)), size2)
	src3 := unsafe.Slice((*byte)(unsafe.Pointer(&c3)), size3)
	src4 := unsafe.Slice((*byte)(unsafe.Pointer(&c4)), size4)
	
	oldArch := meta.Archetype
	setMask := makeMask4(id1, id2, id3, id4)
	if includesAll(oldArch.mask, setMask) {
		slot1 := oldArch.getSlot(id1)
		slot2 := oldArch.getSlot(id2)
		slot3 := oldArch.getSlot(id3)
		slot4 := oldArch.getSlot(id4)
		
		if slot1 == -1 || slot2 == -1 || slot3 == -1 || slot4 == -1 {
			return false
		}
		bytes1 := oldArch.componentData[slot1]
		if meta.Index*size1 >= len(bytes1) {
			return false
		}
		copy(bytes1[meta.Index*size1:(meta.Index+1)*size1], src1)
		bytes2 := oldArch.componentData[slot2]
		if meta.Index*size2 >= len(bytes2) {
			return false
		}
		copy(bytes2[meta.Index*size2:(meta.Index+1)*size2], src2)
		bytes3 := oldArch.componentData[slot3]
		if meta.Index*size3 >= len(bytes3) {
			return false
		}
		copy(bytes3[meta.Index*size3:(meta.Index+1)*size3], src3)
		bytes4 := oldArch.componentData[slot4]
		if meta.Index*size4 >= len(bytes4) {
			return false
		}
		copy(bytes4[meta.Index*size4:(meta.Index+1)*size4], src4)
		
		return true
	} else {
		newMask := orMask(oldArch.mask, setMask)
		var transition Transition
		addMap, ok := w.addTransitions[oldArch]
		if ok {
			if tr, ok := addMap[setMask]; ok {
				transition = tr
			}
		}
		var newArch *Archetype
		if transition.target == nil {
			newArch = w.getOrCreateArchetype(newMask)
			copies := make([]CopyOp, 0, len(oldArch.componentIDs))
			for from, id := range oldArch.componentIDs {
				to := newArch.getSlot(id)
				if to >= 0 {
					copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
				}
			}
			transition = Transition{target: newArch, copies: copies}
			if _, ok := w.addTransitions[oldArch]; !ok {
				w.addTransitions[oldArch] = make(map[maskType]Transition)
			}
			w.addTransitions[oldArch][setMask] = transition
		} else {
			newArch = transition.target
		}

		oldIndex := meta.Index
		newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

		ids := []ComponentID{ id1, id2, id3, id4 }
		srcs := [][]byte{ src1, src2, src3, src4 }
		sizes := []int{ size1, size2, size3, size4 }
		for i, id := range ids {
			idx := newArch.getSlot(id)
			if idx == -1 {
				return false
			}
			bytes := newArch.componentData[idx]
			if oldArch.mask.has(id) {
				copy(bytes[newIndex*sizes[i]:(newIndex+1)*sizes[i]], srcs[i])
			} else {
				bytes = extendByteSlice(bytes, sizes[i])
				copy(bytes[len(bytes)-sizes[i]:], srcs[i])
				newArch.componentData[idx] = bytes
			}
		}

		meta.Archetype = newArch
		meta.Index = newIndex
		w.entitiesSlice[e.ID] = meta

		w.removeEntityFromArchetype(e, oldArch, oldIndex)
		return true
	}
}

// RemoveComponent4 removes 4 components from an entity if present.
// It returns a boolean indicating success.
func RemoveComponent4[T1 any, T2 any, T3 any, T4 any](w *World, e Entity) bool {
	if int(e.ID) >= len(w.entitiesSlice) {
		return false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	id4, ok4 := TryGetID[T4]()
	
	if !ok1 || !ok2 || !ok3 || !ok4 {
		return false
	}

	oldArch := meta.Archetype
	removeMask := makeMask4(id1, id2, id3, id4)
	if !intersects(oldArch.mask, removeMask) {
		return true
	}

	oldIndex := meta.Index

	newMask := andNotMask(oldArch.mask, removeMask)

	var transition Transition
	removeMap, ok := w.removeTransitions[oldArch]
	if ok {
		if tr, ok := removeMap[removeMask]; ok {
			transition = tr
		}
	}
	var newArch *Archetype
	if transition.target == nil {
		newArch = w.getOrCreateArchetype(newMask)
		copies := make([]CopyOp, 0, len(oldArch.componentIDs))
		for from, id := range oldArch.componentIDs {
			if removeMask.has(id) {
				continue
			}
			to := newArch.getSlot(id)
			if to >= 0 {
				copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
			}
		}
		transition = Transition{target: newArch, copies: copies}
		if _, ok := w.removeTransitions[oldArch]; !ok {
			w.removeTransitions[oldArch] = make(map[maskType]Transition)
		}
		w.removeTransitions[oldArch][removeMask] = transition
	} else {
		newArch = transition.target
	}

	newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

	meta.Archetype = newArch
	meta.Index = newIndex
	w.entitiesSlice[e.ID] = meta

	w.removeEntityFromArchetype(e, oldArch, oldIndex)

	return true
}// AddComponent5 adds 5 components to an entity if not already present.
// It returns pointers to the components (existing or new) and a boolean indicating success.
func AddComponent5[T1 any, T2 any, T3 any, T4 any, T5 any](w *World, e Entity) (*T1, *T2, *T3, *T4, *T5, bool) {
	if int(e.ID) >= len(w.entitiesSlice) {
		return nil, nil, nil, nil, nil, false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return nil, nil, nil, nil, nil, false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	id4, ok4 := TryGetID[T4]()
	id5, ok5 := TryGetID[T5]()
	
	if !ok1 || !ok2 || !ok3 || !ok4 || !ok5 {
		return nil, nil, nil, nil, nil, false
	}
	size1 := int(componentSizes[id1])
	size2 := int(componentSizes[id2])
	size3 := int(componentSizes[id3])
	size4 := int(componentSizes[id4])
	size5 := int(componentSizes[id5])
	
	oldArch := meta.Archetype
	addMask := makeMask5(id1, id2, id3, id4, id5)
	if includesAll(oldArch.mask, addMask) {
		slot1 := oldArch.getSlot(id1)
		slot2 := oldArch.getSlot(id2)
		slot3 := oldArch.getSlot(id3)
		slot4 := oldArch.getSlot(id4)
		slot5 := oldArch.getSlot(id5)
		
		if slot1 == -1 || slot2 == -1 || slot3 == -1 || slot4 == -1 || slot5 == -1 {
			return nil, nil, nil, nil, nil, false
		}
		bytes1 := oldArch.componentData[slot1]
		if meta.Index*size1 >= len(bytes1) {
			return nil, nil, nil, nil, nil, false
		}
		bytes2 := oldArch.componentData[slot2]
		if meta.Index*size2 >= len(bytes2) {
			return nil, nil, nil, nil, nil, false
		}
		bytes3 := oldArch.componentData[slot3]
		if meta.Index*size3 >= len(bytes3) {
			return nil, nil, nil, nil, nil, false
		}
		bytes4 := oldArch.componentData[slot4]
		if meta.Index*size4 >= len(bytes4) {
			return nil, nil, nil, nil, nil, false
		}
		bytes5 := oldArch.componentData[slot5]
		if meta.Index*size5 >= len(bytes5) {
			return nil, nil, nil, nil, nil, false
		}
		
		return (*T1)(unsafe.Pointer(&bytes1[meta.Index*size1])), (*T2)(unsafe.Pointer(&bytes2[meta.Index*size2])), (*T3)(unsafe.Pointer(&bytes3[meta.Index*size3])), (*T4)(unsafe.Pointer(&bytes4[meta.Index*size4])), (*T5)(unsafe.Pointer(&bytes5[meta.Index*size5])), true
	}

	newMask := orMask(oldArch.mask, addMask)

	var transition Transition
	addMap, ok := w.addTransitions[oldArch]
	if ok {
		if tr, ok := addMap[addMask]; ok {
			transition = tr
		}
	}
	var newArch *Archetype
	if transition.target == nil {
		newArch = w.getOrCreateArchetype(newMask)
		copies := make([]CopyOp, 0, len(oldArch.componentIDs))
		for from, id := range oldArch.componentIDs {
			to := newArch.getSlot(id)
			if to >= 0 {
				copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
			}
		}
		transition = Transition{target: newArch, copies: copies}
		if _, ok := w.addTransitions[oldArch]; !ok {
			w.addTransitions[oldArch] = make(map[maskType]Transition)
		}
		w.addTransitions[oldArch][addMask] = transition
	} else {
		newArch = transition.target
	}

	oldIndex := meta.Index
	newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

	ids := []ComponentID{ id1, id2, id3, id4, id5 }
	for _, id := range ids {
		if !oldArch.mask.has(id) {
			idx := newArch.getSlot(id)
			if idx == -1 {
				return nil, nil, nil, nil, nil, false
			}
			bytes := newArch.componentData[idx]
			bytes = extendByteSlice(bytes, int(componentSizes[id]))
			newArch.componentData[idx] = bytes
		}
	}

	meta.Archetype = newArch
	meta.Index = newIndex
	w.entitiesSlice[e.ID] = meta

	w.removeEntityFromArchetype(e, oldArch, oldIndex)

	slot1 := newArch.getSlot(id1)
	slot2 := newArch.getSlot(id2)
	slot3 := newArch.getSlot(id3)
	slot4 := newArch.getSlot(id4)
	slot5 := newArch.getSlot(id5)
	
	if slot1 == -1 || slot2 == -1 || slot3 == -1 || slot4 == -1 || slot5 == -1 {
		return nil, nil, nil, nil, nil, false
	}
	bytes1 := newArch.componentData[slot1]
	bytes2 := newArch.componentData[slot2]
	bytes3 := newArch.componentData[slot3]
	bytes4 := newArch.componentData[slot4]
	bytes5 := newArch.componentData[slot5]
	
	return (*T1)(unsafe.Pointer(&bytes1[newIndex*size1])), (*T2)(unsafe.Pointer(&bytes2[newIndex*size2])), (*T3)(unsafe.Pointer(&bytes3[newIndex*size3])), (*T4)(unsafe.Pointer(&bytes4[newIndex*size4])), (*T5)(unsafe.Pointer(&bytes5[newIndex*size5])), true
}

// SetComponent5 sets 5 components for an entity.
// If any component is missing, it adds them; otherwise, updates existing ones.
// It returns a boolean indicating success.
func SetComponent5[T1 any, T2 any, T3 any, T4 any, T5 any](w *World, e Entity, c1 T1, c2 T2, c3 T3, c4 T4, c5 T5) bool {
	if int(e.ID) >= len(w.entitiesSlice) {
		return false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	id4, ok4 := TryGetID[T4]()
	id5, ok5 := TryGetID[T5]()
	
	if !ok1 || !ok2 || !ok3 || !ok4 || !ok5 {
		return false
	}
	size1 := int(componentSizes[id1])
	size2 := int(componentSizes[id2])
	size3 := int(componentSizes[id3])
	size4 := int(componentSizes[id4])
	size5 := int(componentSizes[id5])
	
	src1 := unsafe.Slice((*byte)(unsafe.Pointer(&c1)), size1)
	src2 := unsafe.Slice((*byte)(unsafe.Pointer(&c2)), size2)
	src3 := unsafe.Slice((*byte)(unsafe.Pointer(&c3)), size3)
	src4 := unsafe.Slice((*byte)(unsafe.Pointer(&c4)), size4)
	src5 := unsafe.Slice((*byte)(unsafe.Pointer(&c5)), size5)
	
	oldArch := meta.Archetype
	setMask := makeMask5(id1, id2, id3, id4, id5)
	if includesAll(oldArch.mask, setMask) {
		slot1 := oldArch.getSlot(id1)
		slot2 := oldArch.getSlot(id2)
		slot3 := oldArch.getSlot(id3)
		slot4 := oldArch.getSlot(id4)
		slot5 := oldArch.getSlot(id5)
		
		if slot1 == -1 || slot2 == -1 || slot3 == -1 || slot4 == -1 || slot5 == -1 {
			return false
		}
		bytes1 := oldArch.componentData[slot1]
		if meta.Index*size1 >= len(bytes1) {
			return false
		}
		copy(bytes1[meta.Index*size1:(meta.Index+1)*size1], src1)
		bytes2 := oldArch.componentData[slot2]
		if meta.Index*size2 >= len(bytes2) {
			return false
		}
		copy(bytes2[meta.Index*size2:(meta.Index+1)*size2], src2)
		bytes3 := oldArch.componentData[slot3]
		if meta.Index*size3 >= len(bytes3) {
			return false
		}
		copy(bytes3[meta.Index*size3:(meta.Index+1)*size3], src3)
		bytes4 := oldArch.componentData[slot4]
		if meta.Index*size4 >= len(bytes4) {
			return false
		}
		copy(bytes4[meta.Index*size4:(meta.Index+1)*size4], src4)
		bytes5 := oldArch.componentData[slot5]
		if meta.Index*size5 >= len(bytes5) {
			return false
		}
		copy(bytes5[meta.Index*size5:(meta.Index+1)*size5], src5)
		
		return true
	} else {
		newMask := orMask(oldArch.mask, setMask)
		var transition Transition
		addMap, ok := w.addTransitions[oldArch]
		if ok {
			if tr, ok := addMap[setMask]; ok {
				transition = tr
			}
		}
		var newArch *Archetype
		if transition.target == nil {
			newArch = w.getOrCreateArchetype(newMask)
			copies := make([]CopyOp, 0, len(oldArch.componentIDs))
			for from, id := range oldArch.componentIDs {
				to := newArch.getSlot(id)
				if to >= 0 {
					copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
				}
			}
			transition = Transition{target: newArch, copies: copies}
			if _, ok := w.addTransitions[oldArch]; !ok {
				w.addTransitions[oldArch] = make(map[maskType]Transition)
			}
			w.addTransitions[oldArch][setMask] = transition
		} else {
			newArch = transition.target
		}

		oldIndex := meta.Index
		newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

		ids := []ComponentID{ id1, id2, id3, id4, id5 }
		srcs := [][]byte{ src1, src2, src3, src4, src5 }
		sizes := []int{ size1, size2, size3, size4, size5 }
		for i, id := range ids {
			idx := newArch.getSlot(id)
			if idx == -1 {
				return false
			}
			bytes := newArch.componentData[idx]
			if oldArch.mask.has(id) {
				copy(bytes[newIndex*sizes[i]:(newIndex+1)*sizes[i]], srcs[i])
			} else {
				bytes = extendByteSlice(bytes, sizes[i])
				copy(bytes[len(bytes)-sizes[i]:], srcs[i])
				newArch.componentData[idx] = bytes
			}
		}

		meta.Archetype = newArch
		meta.Index = newIndex
		w.entitiesSlice[e.ID] = meta

		w.removeEntityFromArchetype(e, oldArch, oldIndex)
		return true
	}
}

// RemoveComponent5 removes 5 components from an entity if present.
// It returns a boolean indicating success.
func RemoveComponent5[T1 any, T2 any, T3 any, T4 any, T5 any](w *World, e Entity) bool {
	if int(e.ID) >= len(w.entitiesSlice) {
		return false
	}
	meta := w.entitiesSlice[e.ID]
	if meta.Version != e.Version {
		return false
	}

	id1, ok1 := TryGetID[T1]()
	id2, ok2 := TryGetID[T2]()
	id3, ok3 := TryGetID[T3]()
	id4, ok4 := TryGetID[T4]()
	id5, ok5 := TryGetID[T5]()
	
	if !ok1 || !ok2 || !ok3 || !ok4 || !ok5 {
		return false
	}

	oldArch := meta.Archetype
	removeMask := makeMask5(id1, id2, id3, id4, id5)
	if !intersects(oldArch.mask, removeMask) {
		return true
	}

	oldIndex := meta.Index

	newMask := andNotMask(oldArch.mask, removeMask)

	var transition Transition
	removeMap, ok := w.removeTransitions[oldArch]
	if ok {
		if tr, ok := removeMap[removeMask]; ok {
			transition = tr
		}
	}
	var newArch *Archetype
	if transition.target == nil {
		newArch = w.getOrCreateArchetype(newMask)
		copies := make([]CopyOp, 0, len(oldArch.componentIDs))
		for from, id := range oldArch.componentIDs {
			if removeMask.has(id) {
				continue
			}
			to := newArch.getSlot(id)
			if to >= 0 {
				copies = append(copies, CopyOp{from: from, to: to, size: int(componentSizes[id])})
			}
		}
		transition = Transition{target: newArch, copies: copies}
		if _, ok := w.removeTransitions[oldArch]; !ok {
			w.removeTransitions[oldArch] = make(map[maskType]Transition)
		}
		w.removeTransitions[oldArch][removeMask] = transition
	} else {
		newArch = transition.target
	}

	newIndex := moveEntityBetweenArchetypes(e, oldIndex, oldArch, newArch, transition.copies)

	meta.Archetype = newArch
	meta.Index = newIndex
	w.entitiesSlice[e.ID] = meta

	w.removeEntityFromArchetype(e, oldArch, oldIndex)

	return true
}